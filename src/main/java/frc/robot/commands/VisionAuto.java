// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.

package frc.robot.commands;
import frc.robot.commands.*;
import frc.robot.subsystems.*;
import java.util.Arrays;
import java.util.List;

//import org.apache.commons.collections4.functors.NullIsFalsePredicate;

import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.util.sendable.Sendable;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.DriverStation.Alliance;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.TankDrive;
import frc.robot.LimelightHelpers;
// !! Don't ever use photon for any reason ever, it sucks ass !! 
//import org.photonvision.*;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
//import org.photonvision.targeting.PhotonPipelineResult;
//import org.photonvision.targeting.PhotonTrackedTarget;
import frc.robot.Robot;
import frc.robot.RobotContainer;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.LimelightHelpers.LimelightResults;
import frc.robot.RobotContainer;
/**
 * why is this random comment here? it was empty 
 */
public class VisionAuto extends CommandBase {
//public final SwerveDrive swerveDrive;

public  GrabberExtension grabberExtension;
public  PneumaticGrabber pneumaticGrabber;
public  PneumaticArm pneumaticArm;
public  Elevator elevator;
    double range;
    int iteration;

    // PhotonCamera camera = new PhotonCamera("photonvision"); -- ewwwww 
    PIDController controller = new PIDController(.1, 0, 0);
    //RobotContainer m_robotCtr = RobotContainer.getInstance();
    int goal = 2;
    
    TankDrive tankDrive;
    double rotationSpeed;
    double forwardSpeed;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    private static double calculateHypotenuse(double x, double y) {
        return (Math.sqrt(x*x+y*y));
    }

    public VisionAuto(TankDrive tankDrive,  Elevator elevator,  PneumaticArm pneumaticArm,  PneumaticGrabber pneumaticGrabber, GrabberExtension grabberExtension) {
        this.tankDrive = tankDrive;
        this.elevator = elevator;
        this.pneumaticArm = pneumaticArm;
        this.pneumaticGrabber = pneumaticGrabber;
        this.grabberExtension = grabberExtension;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        // m_subsystem = subsystem;
        // addRequirements(m_subsystem);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {

    }
    // tbh gonna rework this during mr demos ap physics homework review 
    // game plan: connect second camera with known fov to limelight and conduct pose estimation

    // !! do NOT use the camera attached to the grabber for pose estimation! because the camera is  
    // attached to a MOVING ARM, the angle and position of the camera will also change.
    // calculating and compensating for such changes would be innacurate, impractical, and 
    // overall just idiotic. If we REALLY need the extra camera for accurate pose estimation, 
    //we can place 2 more facing to the left and right of the bot, which would also give us a perfect 
    // 360 degree fov !!

    //note that we may use the camera on the claw to properly track cargo and ensure that it is grabbed
    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        
        iteration = iteration + 1;
        if (iteration >= 0) {
            //PhotonPipelineResult results = camera.getLatestResult();
            LimelightHelpers.Results limelightResults = LimelightHelpers.getLatestResults("").targetingResults;
            int selectedTarget = 1;
            if(limelightResults.targets_Fiducials.length > 0){
            LimelightHelpers.LimelightTarget_Fiducial target = Arrays.asList(limelightResults.targets_Fiducials)
            .stream()
              .filter(t -> t.fiducialID == selectedTarget)
                 .findFirst()
                  .get();}
         } //i love how CONCISE java is, so concise that to avoid a ravioli loop of foreaches (and to keep this auto modular) i have to convert from arrays to lists and then back to the type that the array contained
            // c++ was so much nicer ://
            if (iteration >= 0 && iteration <= 500*6){
                pneumaticGrabber.chompOnCargo();
            }
            if (iteration >= 500*1 && iteration <= 500*8) { //if else spaghetti code. works for now.
                //new ArmUp(m_pneumaticArm).execute();
                pneumaticArm.out();
                
           }
           if (iteration >= 500*5 && iteration <= 500*7) {
            //new ArmUp(m_pneumaticArm).execute();
            grabberExtension.extend();
       }
       if (iteration >= 500*6) {
        //new ArmUp(m_pneumaticArm).execute();
        pneumaticGrabber.letGoCargo();
   }
   if (iteration >= 500*7) {
    grabberExtension.retract();
   }
   if (iteration >= 500*8) { //if else spaghetti code. works for now.
    //new ArmUp(m_pneumaticArm).execute();
    pneumaticArm.in(); 
    tankDrive.AutoDrive(-0.3, 0);
    
}

      /*       if (targetList != null) {
                // make sure that target is in view. if not, rotate the robot until it is detected.
                // Rotation speed is the output of the PID controller
                
                double xComp = target.getTargetPose_RobotSpace2D().getTranslation().getX();
                double yComp = target.getTargetPose_RobotSpace2D().getTranslation().getY();
                double theta = target.getTargetPose_RobotSpace().getRotation().getAngle();
                double distanceToTargetMeters = calculateHypotenuse(xComp, yComp);
                //for (PhotonTrackedTarget resultLoop : results.getTargets()) {
                    if (DriverStation.getAlliance() == Alliance.Blue) {

                       // if (resultLoop.getFiducialId() == goal + 5) {
                         //    range = PhotonUtils.calculateDistanceToTargetMeters(
                           //     1.3462, .36, 0,
                               // resultLoop.getPitch());
                            rotationSpeed = -controller.calculate(theta, 1.00);
                       // }
                    }
                    if (DriverStation.getAlliance() == Alliance.Red || DriverStation.getAlliance() == Alliance.Invalid) {

                        if (resultLoop.getFiducialId() == goal) {
                             range = PhotonUtils.calculateDistanceToTargetMeters(
                                1.3462, .36, 0,
                                resultLoop.getPitch());
                            rotationSpeed = -controller.calculate(resultLoop.getPitch(), 1.00);
                        }
                    } else {
                        rotationSpeed = 0.0;
                    }


                    double rangeMeter = .03;
                    // Use this range as the measurement we give to the PID controller.
                     forwardSpeed = -controller.calculate(range, rangeMeter);
                     tankDrive.AutoDrive(forwardSpeed, rotationSpeed);

                }
            }
        }
        
    */ }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }
}
